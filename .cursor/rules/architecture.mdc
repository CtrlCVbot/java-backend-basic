---
alwaysApply: true
---
# 아키텍처 개요 (Architecture Overview)

이 문서는 이 백엔드 프로젝트의 **전체 아키텍처 방향과 주요 설계 결정**을 설명한다.  
“무엇을 지켜야 하는가”는 `.cursor/rules.md`에 정의되어 있으며,  
이 문서는 **“왜 그런 규칙을 선택했는가”**에 초점을 둔다.

---

## 1. 프로젝트 전제 (Context)

이 프로젝트는 다음과 같은 특성을 가진다.

- Java 기반 백엔드
- 장기 운영을 전제로 한 서비스
- 도메인 복잡도 증가 가능성 (물류 / 정산 / 배차 등)
- 조회와 입력의 성격이 다른 트래픽 구조
- 향후 서비스 분리(MSA) 가능성이 높음
- AI IDE(Cursor 등)를 적극 활용하는 개발 환경

이러한 조건에서  
**초기 개발 속도와 장기 유지보수성의 균형**이 가장 중요한 설계 목표였다.

---

## 2. 전체 아키텍처 방향

이 프로젝트는 다음 조합을 기본 아키텍처 방향으로 선택했다.

- **Monorepo 기반 MSA (MSA-ready)**
- **Hexagonal Architecture**
- **Clean Architecture**
- **CQRS (Lite 버전)**

이 조합은 “처음부터 모든 것을 분리하는 MSA”가 아니라,  
**지금은 단순하게 시작하되, 나중에 자연스럽게 분리될 수 있는 구조**를 목표로 한다.

---

## 3. 왜 Monorepo 기반 MSA인가?

### 3.1 서비스는 분리하되, 저장소는 하나로 관리

초기 단계에서 여러 서비스 저장소를 운영하는 것은  
개발·운영 비용 대비 효과가 낮다고 판단했다.

따라서:

- 코드 저장소는 **Monorepo**
- 아키텍처 구조는 **MSA 분리를 전제로 설계**

라는 방식을 선택했다.

이 방식의 기대 효과:

- 공통 코드 관리 용이
- CI/CD 및 개발 규칙의 일관성 유지
- 팀 규모가 커져도 구조를 유지한 채 확장 가능

---

## 4. 왜 Hexagonal + Clean Architecture인가?

### 4.1 도메인 보호가 핵심 목표

이 프로젝트에서 가장 보호해야 할 것은  
프레임워크가 아니라 **비즈니스 규칙(도메인)** 이다.

Hexagonal + Clean Architecture를 선택한 이유는:

- 도메인이 기술(Spring, DB, Kafka)에 종속되지 않도록 분리
- 의존성 방향을 코드 구조로 강제
- 테스트 가능성과 변경 용이성 확보

이를 통해:

- 기술 교체(JPA → R2DBC, DB 변경 등)가 도메인에 영향을 주지 않도록 한다
- “비즈니스 로직이 어디에 있는지” 항상 명확하게 유지한다

---

## 5. 왜 CQRS를 Lite 버전으로 시작하는가?

### 5.1 조회와 입력의 성격 차이

실제 서비스 운영에서는:

- 입력(Command)은 트랜잭션 무결성이 중요하고
- 조회(Query)는 성능과 유연성이 중요하다

하지만 초기부터 완전한 CQRS 분리는  
과도한 복잡도를 초래할 수 있다.

따라서 이 프로젝트는:

- **개념적 Command / Query 분리부터 적용**
- 패키지·유스케이스 레벨에서 책임을 나눔
- 필요해질 때만 기술적으로 분리(JPA → R2DBC)

하는 **CQRS Lite 전략**을 선택했다.

---

## 6. Monolith에서 MSA로의 진화 전략

이 프로젝트는 처음부터 다수의 서비스로 분리하지 않는다.

대신 다음과 같은 **진화 경로**를 전제로 한다.

1. 단일 실행 애플리케이션 (Modular Monolith)
2. 도메인별 모듈 분리 유지
3. 트래픽 / 팀 / 배포 요구가 생기면
4. 해당 모듈을 독립 서비스로 분리

이 방식은:

- 초기 개발 속도를 해치지 않으면서
- 나중에 구조를 갈아엎지 않고도
- 자연스럽게 MSA로 전환할 수 있게 한다

---

## 7. 이벤트 기반 설계를 고려한 이유

향후 다음 요구사항을 대비한다:

- 서비스 간 데이터 결합 필요
- 비동기 처리 증가
- 정산 / 알림 / 상태 변경 이벤트 전파

이를 위해:

- 도메인 이벤트 개념을 초기에 도입
- Kafka 등 이벤트 브로커 사용을 전제로 구조 설계

단, 초기에는 **이벤트 발행 중심**으로 단순하게 시작하며  
복잡한 Saga / CDC / 스트림 처리는 필요 시점에 도입한다.

---

## 8. 무엇을 일부러 하지 않았는가

의도적으로 선택하지 않은 것들:

- 초기 단계의 다중 서비스 분리
- 과도한 인프라 도입
- 완전한 CQRS(Read DB 완전 분리)
- 분산 트랜잭션(Saga) 즉시 도입

이러한 요소들은  
**필요해지는 시점이 명확해질 때 도입**하는 것을 원칙으로 한다.

---

## 9. 이 문서의 역할

- `.cursor/rules.md`  
  → **규칙 / 제약 / 강제**
- `architecture.md`  
  → **맥락 / 이유 / 설계 기록**

이 문서는  
“이 프로젝트가 왜 이렇게 생겼는지”를 설명하기 위한 것이며,  
규칙을 대체하지 않는다.

---

## 10. 정리

이 아키텍처는:

- 지금은 단순하게 시작할 수 있고
- 시간이 지나도 구조를 유지할 수 있으며
- 팀과 시스템이 커질수록 장점이 커지는 방향을 목표로 한다.

아키텍처는 완성된 결과물이 아니라  
**지속적으로 검증되고 조정되는 선택의 기록**이다.
