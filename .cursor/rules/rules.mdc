---
alwaysApply: true
---

# Architecture & Engineering Rules (Monorepo + MSA-ready)
# Domain term: "order" (cargo 금지)
# Updated: 2025-12-23

이 문서는 **이 레포지토리의 헌법**이다.
AI(Cursor 포함)와 사람이 작성하는 모든 코드는 이 규칙을 반드시 따른다.

---

## 0. 최우선 원칙 (Non-Negotiables)

1) **도메인 용어는 `order`를 사용한다.**  
   - `cargo` 용어/패키지/클래스/테이블 명칭은 신규로 만들지 않는다.

2) **Hexagonal + Clean + CQRS(Lite)를 기본 아키텍처로 고정한다.**
   - Domain은 기술 독립(JDK-only)
   - Application은 UseCase(명령/조회) 중심
   - Adapter는 기술 구현만

3) **서비스는 “데이터 소유권(Owner)”을 가진다.**
   - 다른 서비스 데이터에 직접 조인/직접 업데이트/직접 FK 의존 금지
   - 서비스 경계 넘어가는 참조는 **soft-ref(id만)** 로 처리

4) **Cross-service FK 금지(신규 생성 금지).**
   - 기존 FK는 단계적으로 제거한다.

---

## 1. 레포 구조 규칙 (Monorepo)

권장 레포 구조는 아래와 같다.

- `services/*` : 독립 배포 가능한 서비스(기본 단위)
- `shared/*` : 공통 모듈(계약/에러/관측성 등)
- `platform/*` : CI/CD, 배포, 로컬 개발 지원
- `docs/*` : 규칙/아키텍처/컨벤션 문서

예:
- `services/order-service`
- `services/settlement-service`
- `services/master-service`
- `services/iam-service`
- `services/messaging-service`
- `shared/contracts`, `shared/errors`, `shared/observability`, `shared/core`
- `platform/ci`, `platform/deploy`, `platform/dev`

---

## 2. 서비스 내부 아키텍처 규칙 (Hexagonal + Clean)

각 서비스는 반드시 아래 계층을 가진다.

- `domain/*` : 순수 도메인 (JDK-only)
- `application/*` : UseCase (Command/Query 분리)
- `adapter/*` : inbound/outbound (기술 구현)
- `config/*` : Spring 설정/조립(wiring)

### 2.1 Domain 규칙 (가장 엄격)
Domain에는 아래 요소를 **절대 포함하지 않는다**.

- Spring 관련(import 포함)
- JPA/Hibernate 어노테이션
- R2DBC/Reactive 타입(Flux/Mono)
- Kafka/Redis/HTTP/DB 접근
- Lombok
- 프레임워크 유틸 전반

Domain에 들어갈 수 있는 것:
- Entity/Aggregate, Value Object, Domain Service, Domain Event(순수 객체)

### 2.2 Application 규칙
Application은 “업무 흐름”만 담당한다.

- Command / Query 책임을 섞지 않는다.
- Port(인터페이스)를 먼저 정의하고 Adapter가 구현한다.
- 트랜잭션 경계는 Application에서 잡는다(Write 기준).

### 2.3 Adapter 규칙
Adapter는 기술 구현만 한다.

- inbound: REST(MVC), WebFlux, gRPC 등
- outbound: JPA(write), R2DBC(read), Kafka, Redis, External API

Adapter에는 **비즈니스 규칙을 작성하지 않는다.**
(비즈니스 규칙은 Domain/Application로 이동)

---

## 3. CQRS(Lite) 규칙

### 3.1 Command (Write)
- 상태 변경(Create/Update/Cancel/Confirm 등)
- 트랜잭션 무결성 우선
- 기본은 **JPA 기반(Blocking)**

### 3.2 Query (Read)
- 조회 전용
- 상태 변경 금지
- 기본은 JPA 가능(초기), 필요 시 **R2DBC로 확장**
- Query는 “정합성”보다 “속도/유연성”을 우선한다(단, 요구사항 범위 내)

---

## 4. WebFlux + MVC 하이브리드 규칙 (Blocking/Non-Blocking 혼용 가드)

- JPA(Blocking)를 WebFlux Netty 이벤트 루프에서 직접 실행 금지.
- 하이브리드 운영 시 권장:
  - **Command API**: MVC Controller (Blocking/JPA)
  - **Query API**: WebFlux Handler (Reactive/R2DBC 또는 캐시)
- 혼용이 불가피하면:
  - Blocking 작업은 별도 스케줄러/스레드로 격리(원칙적으로 지양)

---

## 5. 데이터 소유권 & DB 분리 규칙 (Phase 1 → Phase 2)

### 5.1 Phase 1 (단일 DB 유지 + schema 분리)
DB는 하나(Postgres/Supabase)일 수 있으나,
스키마로 소유권을 강제한다.

- `order.*`
- `settlement.*`
- `master.*`
- `iam.*`
- `messaging.*`
- `geo.*` (infra)

**각 서비스는 자기 schema만 접근한다.**
(다른 schema 직접 조회/조인 금지)

### 5.2 Phase 2 (서비스별 물리 DB 분리)
서비스 규모/조직/트래픽이 커지면 DB를 물리 분리한다.
Phase 1 규칙을 지키면 Phase 2 전환 비용이 낮아진다.

---

## 6. 서비스 간 데이터 결합 규칙 (조인 대신)

서비스 간 데이터 결합은 아래 중 하나로만 한다.

1) **API Composition (권장 기본)**
   - 예: Settlement 화면에서 order 정보 10컬럼 필요
   - Settlement Query 결과의 `orderId[]`로
     Order의 “요약 배치 API”를 호출해 merge

2) **Event 기반 Read Model (선택/확장)**
   - 조회 성능 요구가 매우 커질 때만 도입
   - 이벤트를 받아 조회 전용 테이블/DB를 구축

### 6.1 Order Summary Batch 규칙(기본 패턴)
- `POST /api/orders/summaries`
- input: `orderIds[]`
- output: `orderId -> summary(<= 10 fields)`
- 캐시(Redis)는 선택(필요 시 도입)

---

## 7. shared 모듈 규칙 (공통 코드의 한계)

`shared/*`는 “공통 재사용”을 위한 영역이지만, 아래를 금지한다.

- 특정 서비스 도메인 규칙의 이동(=공통화 금지)
- 서비스 고유 Entity/UseCase의 공유
- DB/Repository 구현체의 공유

허용 범위:
- `shared/contracts`: 이벤트/DTO 스키마(버전 관리)
- `shared/errors`: 에러 코드/표준 응답
- `shared/observability`: logging/tracing/metrics
- `shared/core`: 원시 타입/공통 유틸(도메인 규칙 X)

---

## 8. 에러/응답/관측성 기본 규칙

- 모든 API는 표준 에러 응답 형태를 따른다.
- traceId(또는 correlationId)를 전 구간 전파한다.
- 로그는 “원인 추적 가능”해야 한다(요청/핵심 식별자 포함).
- 민감정보(주민번호/계좌/토큰/비밀번호/개인정보)는 로그 금지.

---

## 9. 테스트 규칙 (최소 기준)

- Domain: 순수 단위 테스트(프레임워크 없이)
- Application: Port mocking 기반 유스케이스 테스트
- Adapter: 통합 테스트는 필요 범위에서(우선순위 낮음)
- 서비스 간 통합은 API 계약/컨트랙트 테스트를 우선

---

## 10. 작업 프로토콜 (AI 포함)

AI가 작업을 시작하기 전 반드시 선언한다.

- 대상 서비스: (예: order-service)
- 계층: domain / application / adapter / config
- 작업 성격: command(write) / query(read)
- 데이터 소유권: 이 변경이 어느 서비스 schema에 속하는가?

AI는 아래를 절대 하지 않는다.

- 규칙을 우회하기 위한 편의성 리팩터링
- cross-service FK 추가
- 다른 서비스 DB/schema 직접 조회
- Domain에 기술 의존 코드 삽입

규칙 변경이 필요하면:
- 변경 이유/대안/영향범위를 문서로 제안하고, 사용자 승인 후 반영한다.
```

---

