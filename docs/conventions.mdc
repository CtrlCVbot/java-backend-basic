---
alwaysApply: true
---
# Development Conventions (Monorepo + MSA-ready)
# Domain term: "order" (cargo 금지)
# Updated: 2025-12-23

이 문서는 이 레포지토리의 **네이밍/패키지/API/DB/이벤트/테스트/운영 표준**을 정의한다.  
아키텍처 원칙/금지사항은 `.cursor/rules.mdc`가 최우선이며, 충돌 시 rules가 우선한다.

---

## 0. 문서 우선순위

1) `.cursor/rules/rules.mdc` (헌법)
2) `docs/agent.mdc` (AI 작업 프로토콜)
3) `docs/conventions.mdc` (표준/표현)
4) `docs/architecture.mdc` (배경/방향)
5) `docs/tech-stack.mdc` (기술 스택/도입 순서)

---

## 0.1 필수/권장/선택 정의

| 구분 | 의미 | 위반 시 |
|------|------|---------|
| **필수** | 반드시 따라야 함 | PR 거부 |
| **권장** | 따르는 것이 좋음 | 리뷰어 판단 |
| **선택** | 팀 합의로 결정 | 일관성만 유지 |

---

## 1. 용어/도메인 표준

- **도메인 명칭은 `order`로 고정한다.**
  - 코드/패키지/테이블/변수/DTO에서 `cargo` 신규 생성 금지
- 서비스 이름 표준(권장)
  - `order-service`
  - `settlement-service`
  - `master-service`
  - `iam-service`
  - `messaging-service`
  - `geo-service`(infra)

---

## 2. 레포/디렉토리 컨벤션 (Monorepo)

### 2.1 권장 디렉토리
- `services/*` : 서비스(독립 배포 단위)
- `shared/*` : 공통 모듈(계약/관측성/에러/원시타입 등)
- `platform/*` : CI/CD, 배포, 로컬 개발 지원
- `docs/*` : 문서

> 현재 레포가 단일 앱 구조여도, 신규 개발은 “서비스 단위로 분리 가능하도록” 네이밍/구조를 맞춘다.

### 2.2 서비스 디렉토리 네이밍
- kebab-case: `order-service`, `settlement-service`
- 공통 모듈: `shared/errors`, `shared/contracts`, `shared/observability`, `shared/core`

---

## 3. Java 패키지 컨벤션

### 3.1 베이스 패키지
- 서비스별 베이스 패키지(권장):
  - `com.example.order`
  - `com.example.settlement`
  - `com.example.master`
  - `com.example.iam`
  - `com.example.messaging`

### 3.2 서비스 내부 계층 패키지(필수)
각 서비스는 아래 4계층을 반드시 갖는다.

- `...domain`
- `...application`
- `...adapter`
- `...config`

예)
- `com.example.order.domain.order`
- `com.example.order.application.order`
- `com.example.order.adapter.inbound`
- `com.example.order.adapter.outbound`
- `com.example.order.config`

---

## 4. Hexagonal + Clean + CQRS(Lite) 네이밍

### 4.1 Domain
- Aggregate/Entity: `Order`, `SettlementBundle` 등
- Value Object: `OrderId`, `Money`, `Route`, `CompanyId`
- Domain Service: `OrderStatusTransitionDomainService` (의미 기반 권장)
- Domain Event: `OrderCreatedEvent`, `OrderStatusChangedEvent`

> Domain은 JDK-only. Spring/JPA/Lombok 금지(상세는 rules 참조)

### 4.2 Application (UseCase)
#### Command (Write)
- Command: `CreateOrderCommand`, `UpdateOrderStatusCommand`
- Command Handler: `CreateOrderCommandHandler`
- Input Port(선택): `CreateOrderUseCase` (핵심 유스케이스는 인터페이스로)
- Output Port: `OrderWritePort`, `OrderEventPort`

#### Query (Read)
- Query: `GetOrderQuery`, `ListOrdersQuery`
- Query Handler: `GetOrderQueryHandler`
- Output Port: `OrderReadPort`

> **Handler는 “한 유스케이스 = 한 Handler”** 원칙을 권장한다.

### 4.3 Adapter
#### Inbound
- MVC(Command 권장): `OrderCommandController`
- WebFlux(Query 권장): `OrderQueryHandler` 또는 `OrderQueryController`
- gRPC: `OrderGrpcService`

#### Outbound
- JPA(Write): `OrderJpaAdapter`, `OrderJpaRepository`
- R2DBC(Read): `OrderR2dbcAdapter`, `OrderR2dbcRepository`
- Kafka: `OrderEventProducer`, `OrderEventConsumer`
- Redis: `OrderCacheAdapter`
- External: `KakaoClientAdapter`

> `Repository`는 기술 레이어에서만 사용. Application은 Port만 알고 Adapter가 구현한다.

---

## 5. API 컨벤션 (REST 기준)

### 5.1 기본 규칙
- URL: **명사 + 복수형 + kebab-case**
- 동사 금지
- 리소스 식별자는 `{orderId}` 등으로 표준화

#### 5.1.1 API 버전 관리
- **기본값**: URL 버전 (`/api/v1/orders`)
- 버전 업그레이드 트리거:
  - Breaking change (필드 삭제, 타입 변경)
  - 필드 추가는 버전 유지 (backward compatible)
- 구버전 지원 기간: 최소 6개월 (또는 팀 정책)
- 예시:
  - `/api/v1/orders` (현재)
  - `/api/v2/orders` (breaking change 발생 시)

예)
- `POST /api/orders`
- `PUT /api/orders/{orderId}`
- `DELETE /api/orders/{orderId}`
- `GET /api/orders/{orderId}`
- `GET /api/orders`

### 5.2 목록/검색(Query)
- 페이징: `page`(0-base), `size`
- 정렬: `sort=field,asc|desc` (복수 허용)
- 필터: 명시 키 사용 `status=`, `fromDate=`, `toDate=`
- 키워드: `q=`

예)
- `GET /api/orders?page=0&size=20&sort=createdAt,desc&status=IN_PROGRESS&q=seoul`

### 5.3 배치 요약 조회(서비스 결합 표준)
정산 화면 등에서 order 정보를 10컬럼 이내로 결합할 때는 **조인 대신 배치 API**로 한다.

- `POST /api/orders/summaries`
- request:
  - `orderIds: string[]`
- response:
  - `items: OrderSummaryResponse[]`
  - 각 item은 `orderId`를 반드시 포함

> summary 필드는 **10개 이내**로 유지한다. (확장 필요 시 버전 고려)

### 5.4 HTTP Status 기준(권장)
- 200 OK: 조회/수정 성공
- 201 Created: 생성 성공
- 204 No Content: 삭제 성공(응답 바디 없음)
- 400 Bad Request: 검증 실패/요청 오류
- 401 Unauthorized: 인증 실패
- 403 Forbidden: 권한 없음
- 404 Not Found: 리소스 없음
- 409 Conflict: 중복/상태 충돌
- 422 Unprocessable Entity: 도메인 규칙 위반(선택)
- 500 Internal Server Error: 서버 오류

---

## 6. DTO 컨벤션

### 6.1 네이밍
- Request: `CreateOrderRequest`, `UpdateOrderStatusRequest`
- Response: `OrderResponse`, `OrderSummaryResponse`
- 내부 전달(Command/Query): `CreateOrderCommand`, `GetOrderQuery`

### 6.2 금지
- Domain Entity를 API Response로 직접 반환 금지
- Adapter에서 Domain 객체를 그대로 노출 금지

---

## 7. 에러 응답/에러 코드 표준

### 7.1 표준 에러 응답(JSON)
```json
{
  "code": "ORDER_NOT_FOUND",
  "message": "주문을 찾을 수 없습니다.",
  "traceId": "optional",
  "details": {
    "orderId": "..."
  }
}
````

### 7.2 에러 코드 규칙

* 대문자 스네이크: `ORDER_NOT_FOUND`
* 서비스별 prefix 권장:

  * `ORDER_*`, `SETTLEMENT_*`, `MASTER_*`, `IAM_*`
* `details`에는 민감정보 금지(토큰/계좌/개인정보)

---

## 8. 예외 처리 컨벤션

### 8.1 예외 계층 구조
```
DomainException (Domain 계층 - 추상)
├── OrderNotFoundException
├── OrderAlreadyConfirmedException
├── InvalidOrderStatusTransitionException
└── ...

ApplicationException (Application 계층 - 추상)
├── UnauthorizedAccessException
├── ValidationException
└── ...

InfrastructureException (Adapter 계층 - 추상)
├── DatabaseConnectionException
├── ExternalApiException
└── ...
```

### 8.2 예외 발생 위치

| 계층 | 예외 종류 | 예시 |
|------|-----------|------|
| Domain | 도메인 규칙 위반 | `InvalidOrderStatusTransitionException` |
| Application | 권한/검증/존재 확인 | `OrderNotFoundException`, `UnauthorizedAccessException` |
| Adapter | 기술 오류 | `DatabaseConnectionException` |

### 8.3 예외 처리 위치
- **Inbound Adapter**에서 `@RestControllerAdvice`로 통합 처리
- Handler/Service에서 catch 하지 않고 상위로 전파
- 표준 에러 응답으로 변환

### 8.4 예외 처리 예시
```java
// Domain 예외 정의
public class OrderNotFoundException extends DomainException {
    public OrderNotFoundException(OrderId orderId) {
        super("ORDER_NOT_FOUND", "주문을 찾을 수 없습니다: " + orderId.value());
    }
}

// 글로벌 예외 핸들러
@RestControllerAdvice
public class GlobalExceptionHandler {

    @ExceptionHandler(DomainException.class)
    public ResponseEntity<ErrorResponse> handleDomainException(DomainException e) {
        return ResponseEntity
            .status(HttpStatus.UNPROCESSABLE_ENTITY)
            .body(new ErrorResponse(e.getCode(), e.getMessage()));
    }

    @ExceptionHandler(OrderNotFoundException.class)
    public ResponseEntity<ErrorResponse> handleNotFound(OrderNotFoundException e) {
        return ResponseEntity
            .status(HttpStatus.NOT_FOUND)
            .body(new ErrorResponse(e.getCode(), e.getMessage()));
    }
}
```

---

## 9. DB 컨벤션 (Phase 1: 단일 DB + schema 분리)

### 9.1 schema 네이밍(권장)

* `order.*`
* `settlement.*`
* `master.*`
* `iam.*`
* `messaging.*`
* `geo.*`

### 9.2 테이블/컬럼 네이밍

* 테이블: `snake_case` 복수형 권장(팀 정책에 맞춰 일관성 유지)
* 컬럼: `snake_case`
* 기본 키: `id`
* 참조 키(soft-ref): `order_id`, `company_id`, `driver_id` 등

### 9.3 Cross-service FK 금지

* 다른 schema의 테이블에 FK로 묶지 않는다.
* 서비스 간 참조는 `*_id` **soft-ref**로만 유지
* 정합성은 애플리케이션 로직/배치조회/API 계약/이벤트로 보완한다.

---

## 10. 이벤트 컨벤션 (선택/확장)

### 10.1 이벤트 네이밍

* 이벤트명: `OrderCreated`, `OrderStatusChanged`, `SettlementBundleConfirmed`
* 버전: `v1`, `v2` (contracts에서 관리)

### 10.2 토픽 네이밍(권장)

* `{service}.{entity}.{event}.v{n}`

  * 예: `order.order.created.v1`

### 10.3 이벤트 스키마 위치

* `shared/contracts/events/...` 아래에서 버전 관리
* 이벤트 payload는 DTO로 정의하고 backward compatibility를 우선한다.

---

## 11. 로깅/트레이싱/관측성

* 모든 요청은 `traceId`(또는 correlation-id)를 전파한다.
* 로그는 식별자를 반드시 포함한다:

  * `orderId`, `settlementBundleId`, `companyId` 등
* 민감정보 로그 금지:

  * 토큰, 비밀번호, 계좌 전문, 개인정보

권장 로그 포맷(의미):

* `[Service][Layer] action - key=value...`

---

## 12. 테스트 컨벤션

* Domain 테스트: `OrderTest`, `OrderStatusTransitionDomainServiceTest`
* Application 테스트: `CreateOrderCommandHandlerTest`
* Adapter 통합 테스트: `OrderApiIntegrationTest`(필요 범위에서)

테스트 우선순위(권장):

1. Domain
2. Application(UseCase)
3. Adapter(필요 시)

---

## 13. 커밋/브랜치/PR 컨벤션(요약)

### 13.1 커밋 메시지

* `feat: ...`
* `fix: ...`
* `refactor: ...`
* `docs: ...`
* `test: ...`
* `chore: ...`

### 13.2 PR

* PR은 “문제 → 변경 → 영향 → 테스트” 순으로 작성
* 서비스 경계를 넘는 변경(contracts/shared)은 영향 서비스 명시

---

## 14. WebFlux + MVC 하이브리드 컨벤션(권장 운영)

* Command(Write): MVC Controller + JPA (Blocking)
* Query(Read): WebFlux + R2DBC(또는 캐시)
* 혼용이 불가피하면 Blocking 작업 격리(원칙적으로 지양)

---

## 15. 체크리스트 (변경 전 자가점검)

* [ ] `order` 용어 사용했는가? (`cargo` 금지)
* [ ] 이 변경은 어느 서비스 소유 데이터인가?
* [ ] Command/Query가 섞이지 않았는가?
* [ ] cross-service FK/조인이 추가되지 않았는가?
* [ ] 표준 에러 응답/코드를 따르는가?
* [ ] API Response로 Domain Entity를 노출하지 않았는가?

