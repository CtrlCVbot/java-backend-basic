---
alwaysApply: true
---

# AI Agent Protocol (Cursor / Copilot / Claude / etc.)
# Domain term: "order" (cargo 금지)
# Updated: 2025-12-23

이 문서는 AI(예: Cursor)가 이 레포지토리에서 작업할 때 반드시 따르는 **작업 프로토콜**이다.  
아키텍처 원칙/금지사항은 `.cursor/rules.mdc`가 최우선이며, 충돌 시 rules가 우선한다.

---

## 0. 절대 규칙 (Non-Negotiables)

AI는 아래를 절대 하지 않는다.

1) Domain에 Spring/JPA/Reactive(Kafka/Redis 포함) 의존 코드를 넣지 않는다.
2) Command/Query 책임을 섞지 않는다.
3) 서비스 경계를 넘는 조인/직접 DB 접근/교차 FK를 추가하지 않는다.
4) Adapter에 비즈니스 규칙(도메인 로직)을 넣지 않는다.
5) API Response로 Domain Entity를 직접 반환하지 않는다.
6) 도메인 명칭은 `order`로 고정한다. `cargo` 신규 생성 금지.

---

## 1. 작업 시작 선언(필수)

AI는 작업을 시작하기 전에 반드시 아래 “작업 선언문”을 먼저 작성한다.

### 1.1 작업 선언문 템플릿
- 대상 서비스: `order-service | settlement-service | master-service | iam-service | messaging-service | (기타)`
- 계층: `domain | application | adapter(inbound/outbound) | config`
- 작업 유형: `command(write) | query(read) | shared(contract/errors/obs) | platform(ci/deploy)`
- 데이터 소유권: `order.* | settlement.* | master.* | iam.* | messaging.* | geo.* | none`
- 변경 범위: `파일 목록 + 영향 모듈`
- 완료 기준(DoD): `테스트/빌드/동작 확인 항목`

> 선언문이 없으면 작업을 진행하지 않는다.

### 1.2 작업 선언문 예시

#### Command 예시
```
- 대상 서비스: `order-service`
- 계층: `application`, `adapter(outbound/jpa)`, `adapter(inbound/rest)`
- 작업 유형: `command(write)`
- 데이터 소유권: `order.*`
- 변경 범위:
  - `CreateOrderCommand.java` (신규)
  - `CreateOrderCommandHandler.java` (신규)
  - `OrderWritePort.java` (수정)
  - `OrderJpaAdapter.java` (수정)
  - `OrderCommandController.java` (수정)
- 완료 기준(DoD):
  - `CreateOrderCommandHandlerTest` 통과
  - 빌드 성공
  - API 호출 시 주문 생성 확인
```

#### Query 예시
```
- 대상 서비스: `order-service`
- 계층: `application`, `adapter(outbound/r2dbc)`, `adapter(inbound/rest)`
- 작업 유형: `query(read)`
- 데이터 소유권: `order.*` (읽기 전용)
- 변경 범위:
  - `GetOrderQuery.java` (신규)
  - `GetOrderQueryHandler.java` (신규)
  - `OrderReadPort.java` (신규)
  - `OrderR2dbcAdapter.java` (신규)
  - `OrderQueryController.java` (신규)
- 완료 기준(DoD):
  - `GetOrderQueryHandlerTest` 통과
  - 빌드 성공
  - API 호출 시 주문 조회 확인
```

---

## 2. 작업 단위(권장) — Vertical Slice

AI는 큰 기능을 한 번에 구현하지 않고, 아래 단위로 나눈다.

### 2.1 기본 단위(권장)
- Command 1개(Write) 또는 Query 1개(Read)
  - DTO(Request/Response) + Handler + Port + Adapter + 테스트

예)
- `CreateOrderCommand` + `CreateOrderCommandHandler` + `OrderWritePort` + `OrderJpaAdapter` + 테스트

---

## 3. 계층별 구현 순서 (필수 흐름)

### 3.1 Command(Write) 구현 순서
1) Application: Command/Handler/Port 정의
2) Domain: 필요한 도메인 규칙/엔티티/VO 추가
3) Outbound Adapter: JPA 구현(Write)
4) Inbound Adapter: MVC Controller(Command)
5) Config: Wiring(Bean 등록)
6) 테스트: Domain/Application 최소 1개 이상

### 3.2 Query(Read) 구현 순서
1) Application: Query/Handler/ReadPort 정의
2) Outbound Adapter: R2DBC 또는 JPA Read 구현
3) Inbound Adapter: WebFlux Handler 또는 Query Controller
4) 테스트: Application(핵심) 우선

예)
- `GetOrderQuery` + `GetOrderQueryHandler` + `OrderReadPort` + `OrderR2dbcAdapter` + 테스트
- `ListOrdersQuery` + `ListOrdersQueryHandler` + `OrderReadPort` (재사용) + 테스트

#### 3.2.1 Query 구현 상세 예시
```java
// 1) Query 정의
public record GetOrderQuery(OrderId orderId) {}

// 2) ReadPort 정의
public interface OrderReadPort {
    Optional<OrderReadModel> findById(OrderId id);
}

// 3) QueryHandler 구현
@Service
@RequiredArgsConstructor
public class GetOrderQueryHandler {
    private final OrderReadPort orderReadPort;

    public OrderResponse handle(GetOrderQuery query) {
        return orderReadPort.findById(query.orderId())
            .map(OrderResponse::from)
            .orElseThrow(() -> new OrderNotFoundException(query.orderId()));
    }
}

// 4) Outbound Adapter 구현
@Repository
@RequiredArgsConstructor
public class OrderR2dbcAdapter implements OrderReadPort {
    private final OrderR2dbcRepository repository;

    @Override
    public Optional<OrderReadModel> findById(OrderId id) {
        return repository.findById(id.value())
            .map(this::toReadModel);
    }
}

// 5) Inbound Adapter (Controller)
@RestController
@RequiredArgsConstructor
public class OrderQueryController {
    private final GetOrderQueryHandler handler;

    @GetMapping("/api/orders/{orderId}")
    public OrderResponse getOrder(@PathVariable String orderId) {
        return handler.handle(new GetOrderQuery(OrderId.of(orderId)));
    }
}
```

---

## 4. Command/Query 분리 규칙 (필수)

### 4.1 Command는 반드시 “상태 변경”만
- Create/Update/Cancel/Confirm/Complete 등
- 조회는 최소화(필요 시 존재 확인 수준)

### 4.2 Query는 반드시 “조회”만
- Query에서 DB 업데이트/이벤트 발행/상태 전이 금지

---

## 5. 서비스 간 결합 규칙 (필수)

### 5.1 조인 금지
- 다른 서비스 데이터는 DB 조인으로 가져오지 않는다.

### 5.2 결합 방법은 2개만 허용
1) **API Composition (기본)**
   - 예: 정산 화면에서 order 10컬럼 필요
   - settlement 조회 결과에서 `orderId[]`를 수집하고
   - order의 배치 요약 API로 가져와 merge

2) **Event 기반 Read Model (확장)**
   - 대량 조회/초저지연이 필요할 때만 도입
   - `shared/contracts`로 이벤트 스키마 관리

### 5.3 Order Summary Batch API 규격(기본 패턴)
- `POST /api/orders/summaries`
- request: `orderIds: string[]`
- response: `items: OrderSummaryResponse[]`
- summary는 **10개 필드 이내** 유지

---

## 6. DB 작업 프로토콜 (Phase 1: 단일 DB + schema 분리)

AI는 DB 변경 시 반드시 아래를 지킨다.

1) 테이블 소유 서비스 확인(Owner)
2) 스키마 확인(Phase 1)
   - `order.*`, `settlement.*`, `master.*`, `iam.*`, `messaging.*`, `geo.*`
3) cross-service FK 추가 금지
4) 참조는 soft-ref(`*_id`)로 처리

> migration/DDL을 제안할 때는 “왜 필요한지/대안은 무엇인지/리스크”를 함께 작성한다.

---

## 7. 변경 안전장치(필수)

AI는 코드 생성 후 반드시 아래를 수행한다.

### 7.1 컴파일/빌드 체크
- 프로젝트 빌드가 깨지지 않도록 한다.

### 7.2 테스트(최소 기준)
- Domain 또는 Application 테스트 1개 이상 추가/수정
- 가능하면 유스케이스 단위 테스트를 우선

### 7.3 금지사항 점검
- Domain에 Spring/JPA/Reactive import가 들어갔는지 확인
- Command/Query가 섞였는지 확인
- Response에 Domain Entity가 노출되는지 확인
- 다른 서비스 DB/schema 직접 접근이 없는지 확인

---

## 8. PR/커밋 작성 규칙(권장)

### 8.1 PR 설명(권장 포맷)
- 문제(Why)
- 변경(What)
- 영향(Impact: 서비스/모듈)
- 테스트(How verified)
- 롤백(Backout plan, 필요한 경우)

### 8.2 커밋 메시지
- `feat: ...`
- `fix: ...`
- `refactor: ...`
- `docs: ...`
- `test: ...`
- `chore: ...`

---

## 9. 작업 종료 보고(필수)

AI는 작업 완료 시 아래를 보고한다.

- 변경 요약(핵심 3줄)
- 수정/추가된 파일 목록
- 아키텍처 준수 여부 체크(Yes/No + 근거)
- 테스트 실행 결과(무엇을/어떻게)
- 남은 리스크/후속 작업(있다면)

---

## 10. AI 작업 요청 템플릿(사용자용)

사용자는 아래 템플릿으로 AI에게 작업을 요청한다.

- 목표: (예: 정산 목록 조회 API에 order summary merge)
- 대상 서비스: (예: settlement-service)
- 작업 유형: command/query
- 스키마 소유권: (예: settlement.*)
- 요구사항: (API, 필드, 예외, 성능)
- 제한사항: (조인 금지, summary 10컬럼, etc.)
- 완료 기준: (테스트/문서/빌드)

