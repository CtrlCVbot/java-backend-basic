---
alwaysApply: true
---

# Monorepo + MSA-ready Architecture
# Domain term: "order" (cargo 금지)
# Updated: 2025-12-23

## 1. 이 문서의 목적

이 문서는 `java-backend-basic` 레포의 **아키텍처 방향성**과 **구현 원칙**을 정의한다.

- 2025년 기준 실무 주류 트렌드인 **Monorepo + MSA**를 목표로 한다.
- 단, 초기에는 현실적으로 **Phase 1(단일 DB + schema 분리)** 로 시작하고,
  필요해지면 **Phase 2(서비스별 물리 DB 분리)** 로 진화한다.
- 아키텍처 구현 방식은 **Hexagonal + Clean Architecture + CQRS(Lite)** 를 기본으로 한다.

> 규칙 충돌 시 우선순위:
> 1) `.cursor/rules.mdc`  
> 2) `docs/agent.mdc`  
> 3) `docs/conventions.mdc`  
> 4) `docs/architecture.md`

---

## 2. 핵심 결론(요약)

이 레포의 최종 지향점은 아래 조합이다.

- **Monorepo**: 코드/공통 모듈/CI를 중앙에서 관리
- **MSA**: 서비스는 독립 배포/독립 확장/독립 장애 격리
- **Hexagonal + Clean**: 도메인 중심 설계 + 포트/어댑터 분리
- **CQRS(Lite)**: 쓰기(Command)와 읽기(Query) 책임 분리

그리고 “데이터 결합”은 원칙적으로 아래 2개만 허용한다.

1) **API Composition(기본)**  
2) **Event 기반 Read Model(확장/필요 시)**

---

## 3. 설계 원칙(Non-Negotiables)

### 3.1 도메인 용어 고정
- 모든 코드/패키지/DTO/테이블에서 **`order`** 용어를 사용한다.
- `cargo` 용어/패키지는 신규로 만들지 않는다.

### 3.2 계층 분리(도메인 기술 독립)
- Domain: JDK-only (Spring/JPA/Reactive/Kafka/Redis/Lombok 금지)
- Application: UseCase 중심, Command/Query 분리
- Adapter: 기술 구현만 (Controller/DB/Kafka/Redis/External)
- Config: 조립(wiring)

### 3.3 서비스 데이터 소유권(Owner)
- 각 서비스는 자기 데이터의 **소유권**을 가진다.
- 서비스 경계를 넘는:
  - DB 조인 금지
  - 직접 업데이트 금지
  - cross-service FK 금지(신규 금지, 기존은 단계적 제거)
- 서비스 간 참조는 **soft-ref(id만)** 로 한다.

---

## 4. 목표 아키텍처(런타임 구조)

```mermaid
flowchart TB
  U((Client/Web/App)) --> GW[API Gateway / BFF]

  GW --> OS[Order Service]
  GW --> SS[Settlement Service]
  GW --> MS[Master Data Service]
  GW --> IAM[IAM/Auth Service]
  GW --> NS[Messaging Service]

  OS --> ODB[(Order DB)]
  SS --> SDB[(Settlement DB)]
  MS --> MDB[(Master DB)]
  IAM --> ADB[(IAM DB)]
  NS --> NDB[(Messaging DB)]

  OS --> EB[(Event Bus: Kafka)]
  SS --> EB
  MS --> EB
  IAM --> EB
  NS --> EB
````

> 초기에는 DB가 하나일 수 있다(Phase 1).
> 다만 “소유권”과 “조인 금지” 규칙을 지키면 Phase 2로 전환 비용이 매우 낮아진다.

---

## 5. 레포 구조(모노레포 표준)

```text
java-backend-basic/
├─ services/
│  ├─ order-service/
│  ├─ settlement-service/
│  ├─ master-service/
│  ├─ iam-service/
│  └─ messaging-service/
├─ shared/
│  ├─ contracts/
│  ├─ errors/
│  ├─ observability/
│  └─ core/
├─ platform/
│  ├─ ci/
│  ├─ deploy/
│  └─ dev/
├─ docs/
│  ├─ architecture.md
│  ├─ agent.mdc
│  └─ conventions.mdc
└─ .cursor/
   └─ rules.mdc
```

### 5.1 shared 모듈의 “허용 범위”

* `shared/contracts`: 이벤트/DTO 스키마(버전 관리)
* `shared/errors`: 에러 코드/표준 응답
* `shared/observability`: 로깅/트레이싱/메트릭
* `shared/core`: 원시 타입/공통 유틸(도메인 규칙 금지)

> 금지: 특정 서비스의 도메인 규칙(비즈니스 로직)을 shared로 올리는 행위

---

## 6. 서비스 내부 구조( Hexagonal + Clean + CQRS Lite )

각 서비스는 아래 구조를 가진다.

```text
com.example.<service>/
├─ domain/
│  └─ order/ ...
├─ application/
│  └─ order/
│     ├─ command/
│     │  ├─ handler/
│     │  └─ port/
│     └─ query/
│        ├─ handler/
│        └─ port/
├─ adapter/
│  ├─ inbound/
│  │  ├─ rest/        (MVC Controller 권장: Command)
│  │  ├─ webflux/     (WebFlux 권장: Query)
│  │  └─ grpc/
│  └─ outbound/
│     ├─ jpa/         (Write)
│     ├─ r2dbc/       (Read)
│     ├─ kafka/
│     ├─ redis/
│     └─ external/
└─ config/
```

### 6.1 CQRS(Lite) 적용 방식

* **Command(Write)**: 상태 변경(Create/Update/Cancel/Confirm 등)
* **Query(Read)**: 조회 전용(상태 변경 금지)

> 초기에는 Query도 JPA로 시작할 수 있으나,
> 조회 병목이 생기면 Query만 R2DBC/캐시로 최적화한다.

---

## 7. WebFlux + MVC 하이브리드 운영 원칙

이 레포는 “둘 다 가능”하지만 **혼용 시 사고를 막기 위해 기본값을 고정**한다.

* Command(Write): **Spring MVC + JPA(Blocking)**
* Query(Read): **WebFlux + R2DBC(Non-Blocking) 또는 캐시**

금지:

* WebFlux Netty 이벤트 루프에서 JPA(Blocking) 직접 실행

---

## 8. 데이터 전략: Phase 1 → Phase 2 진화

### 8.1 Phase 1: 단일 DB + schema 분리(권장 시작점)

물리 DB는 하나(Postgres/Supabase)라도, schema로 소유권을 강제한다.

* `order.*`
* `settlement.*`
* `master.*`
* `iam.*`
* `messaging.*`
* `geo.*` (infra)

원칙:

* 각 서비스는 **자기 schema만** 접근한다.
* cross-service FK 신규 금지(기존은 단계적 제거)
* 참조는 `*_id` soft-ref로만 유지한다.

### 8.2 Phase 2: 서비스별 물리 DB 분리(필요 시)

트래픽/조직/배포 충돌이 커지면 DB를 물리적으로 분리한다.

* Order DB / Settlement DB / Master DB / IAM DB …

Phase 1 원칙을 잘 지키면,

* “조인 의존”이 없어서
* 마이그레이션 난이도가 크게 낮아진다.

---

## 9. 서비스 간 데이터 결합(조인 대신)

### 9.1 기본: API Composition(권장)

정산 화면 등에서 order 정보가 필요하면 DB 조인이 아니라 API로 결합한다.

**특히 현재 요구사항: “정산 화면에 order 컬럼 10개 이내”**
→ API Composition이 가장 효율적이다.

패턴:

1. Settlement Query에서 `orderId[]` 수집
2. `POST /api/orders/summaries` 로 배치 조회
3. 서버(또는 BFF)에서 merge하여 응답

```mermaid
flowchart LR
  UI((UI)) --> GW[Gateway/BFF]
  GW --> SAPI[Settlement Query API]
  SAPI -->|orderIds[]| OAPI[Order Summary Batch API]
  SAPI --> GW --> UI
```

### 9.2 확장: Event 기반 Read Model(필요 시)

아래 조건이 생기면 Read Model 도입을 검토한다.

* 대량 목록 + 다중 조합 조회가 상시 발생
* API Composition으로 지연이 커짐
* 쿼리 최적화 비용이 증가

도입 방식:

* `shared/contracts`로 이벤트 스키마 관리
* Kafka 구독으로 조회 전용 테이블/DB 구축

---

## 10. 서비스/테이블 소유권(요약)

대표 소유권(핵심만):

* **Order Service**: `orders`, `order_dispatches`, `order_*`
* **Settlement Service**: `order_sales/purchases`, `*_bundles/*`, `charge_*`, `tax_invoices`, `invoice_issue_logs`
* **Master Service**: `companies`, `drivers`, `addresses`, `*_change_logs`
* **IAM Service**: `users`, `user_tokens`, `user_*_logs`
* **Messaging Service**: `sms_*`
* **Geo/Infra**: `distance_cache`, `kakao_api_usage`

---

## 11. 관측성/에러/보안 기본 원칙

* 모든 요청은 traceId(correlationId)를 전파한다.
* 표준 에러 응답(JSON)을 유지한다(코드/메시지/traceId/details).
* 민감정보 로그 금지(토큰/계좌/개인정보).
* 서비스 간 호출도 동일한 traceId로 연결한다.

---

## 12. 테스트 전략(최소 기준)

우선순위:

1. Domain 단위 테스트(JDK-only)
2. Application 유스케이스 테스트(Port mocking)
3. Adapter 통합 테스트(필요 범위에서)

목표:

* 도메인 규칙/상태 전이를 테스트로 고정해 “AI 생성 코드 품질”을 지킨다.

---

## 13. 개발/운영 로드맵(권장)

1. **0단계**: rules/agent/conventions로 가드레일 고정
2. **1단계**: Monorepo 뼈대 + order-service Vertical Slice 1개 완성
3. **2단계**: settlement-service + Order Summary Batch 패턴 확립
4. **3단계**: schema 분리(Phase 1) 적용 및 cross-service FK 제거/금지
5. **4단계**: 규모/조직/트래픽에 따라 물리 DB 분리(Phase 2)
6. **5단계(옵션)**: Read Model/Query Aggregator 도입

---

## 14. 신규 기능 추가 시 “DoD(완료 기준)” 체크리스트

* [ ] 대상 서비스/계층/command-query/소유 schema가 명확한가?
* [ ] Domain에 기술 의존이 없는가?
* [ ] Command/Query가 섞이지 않았는가?
* [ ] cross-service 조인/FK가 추가되지 않았는가?
* [ ] 표준 에러 응답/에러 코드 규칙을 따르는가?
* [ ] Domain 또는 Application 테스트가 최소 1개 이상 추가/수정되었는가?

---

