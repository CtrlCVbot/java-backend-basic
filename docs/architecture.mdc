---
alwaysApply: true
---

# Monorepo + MSA-ready Architecture
# Domain term: "order" (cargo 금지)
# Updated: 2025-12-23

## 1. 이 문서의 목적

이 문서는 `java-backend-basic` 레포의 **아키텍처 방향성**과 **구현 원칙**을 정의한다.

- 2025년 기준 실무 주류 트렌드인 **Monorepo + MSA**를 목표로 한다.
- 단, 초기에는 현실적으로 **Phase 1(단일 DB + schema 분리)** 로 시작하고,
  필요해지면 **Phase 2(서비스별 물리 DB 분리)** 로 진화한다.
- 아키텍처 구현 방식은 **Hexagonal + Clean Architecture + CQRS(Lite)** 를 기본으로 한다.

> 규칙 충돌 시 우선순위:
> 1) `.cursor/rules/rules.mdc` (헌법)
> 2) `docs/agent.mdc` (AI 작업 프로토콜)
> 3) `docs/conventions.mdc` (표준/표현)
> 4) `docs/architecture.mdc` (배경/방향)
> 5) `docs/tech-stack.mdc` (기술 스택/도입 순서)

---

## 2. 핵심 결론(요약)

이 레포의 최종 지향점은 아래 조합이다.

- **Monorepo**: 코드/공통 모듈/CI를 중앙에서 관리
- **MSA**: 서비스는 독립 배포/독립 확장/독립 장애 격리
- **Hexagonal + Clean**: 도메인 중심 설계 + 포트/어댑터 분리
- **CQRS(Lite)**: 쓰기(Command)와 읽기(Query) 책임 분리

그리고 “데이터 결합”은 원칙적으로 아래 2개만 허용한다.

1) **API Composition(기본)**  
2) **Event 기반 Read Model(확장/필요 시)**

---

## 3. 설계 원칙(Non-Negotiables)

> 상세 규칙은 `.cursor/rules/rules.mdc` 참조

핵심 원칙 요약:
- **도메인 용어**: `order` 고정, `cargo` 금지
- **계층 분리**: Domain은 JDK-only (기술 독립)
- **데이터 소유권**: 각 서비스는 자기 schema만 접근, cross-service 조인/FK 금지
- **참조 방식**: soft-ref(id만) 사용

---

## 4. 목표 아키텍처(런타임 구조)

```mermaid
flowchart TB
  U((Client/Web/App)) --> GW[API Gateway / BFF]

  GW --> OS[Order Service]
  GW --> SS[Settlement Service]
  GW --> MS[Master Data Service]
  GW --> IAM[IAM/Auth Service]
  GW --> NS[Messaging Service]

  OS --> ODB[(Order DB)]
  SS --> SDB[(Settlement DB)]
  MS --> MDB[(Master DB)]
  IAM --> ADB[(IAM DB)]
  NS --> NDB[(Messaging DB)]

  OS --> EB[(Event Bus: Kafka)]
  SS --> EB
  MS --> EB
  IAM --> EB
  NS --> EB
````

> 초기에는 DB가 하나일 수 있다(Phase 1).
> 다만 “소유권”과 “조인 금지” 규칙을 지키면 Phase 2로 전환 비용이 매우 낮아진다.

---

## 5. 레포 구조(모노레포 표준)

```text
java-backend-basic/
├─ services/
│  ├─ order-service/
│  ├─ settlement-service/
│  ├─ master-service/
│  ├─ iam-service/
│  └─ messaging-service/
├─ shared/
│  ├─ contracts/
│  ├─ errors/
│  ├─ observability/
│  └─ core/
├─ platform/
│  ├─ ci/
│  ├─ deploy/
│  └─ dev/
├─ docs/
│  ├─ architecture.md
│  ├─ agent.mdc
│  └─ conventions.mdc
└─ .cursor/
   └─ rules/
      └─ rules.mdc
```

### 5.1 shared 모듈의 "허용 범위"

* `shared/contracts`: 이벤트/DTO 스키마(버전 관리)
* `shared/errors`: 에러 코드/표준 응답
* `shared/observability`: 로깅/트레이싱/메트릭
* `shared/core`: 원시 타입/공통 유틸(도메인 규칙 금지)

> 금지: 특정 서비스의 도메인 규칙(비즈니스 로직)을 shared로 올리는 행위

### 5.2 멀티 모듈 Gradle 설정 예시

#### settings.gradle.kts
```kotlin
rootProject.name = "java-backend-basic"

// Services
include("services:order-service")
include("services:settlement-service")
include("services:master-service")
include("services:iam-service")
include("services:messaging-service")

// Shared modules
include("shared:contracts")
include("shared:errors")
include("shared:observability")
include("shared:core")
```

#### build.gradle.kts (root)
```kotlin
plugins {
    java
    id("org.springframework.boot") version "3.2.0" apply false
    id("io.spring.dependency-management") version "1.1.4" apply false
}

subprojects {
    apply(plugin = "java")

    java {
        sourceCompatibility = JavaVersion.VERSION_21
    }

    repositories {
        mavenCentral()
    }
}
```

#### services/order-service/build.gradle.kts
```kotlin
plugins {
    id("org.springframework.boot")
    id("io.spring.dependency-management")
}

dependencies {
    implementation(project(":shared:errors"))
    implementation(project(":shared:observability"))

    implementation("org.springframework.boot:spring-boot-starter-web")
    implementation("org.springframework.boot:spring-boot-starter-data-jpa")
    // ...
}
```

---

## 6. 서비스 내부 구조( Hexagonal + Clean + CQRS Lite )

각 서비스는 아래 구조를 가진다.

```text
com.example.<service>/
├─ domain/
│  └─ order/ ...
├─ application/
│  └─ order/
│     ├─ command/
│     │  ├─ handler/
│     │  └─ port/
│     └─ query/
│        ├─ handler/
│        └─ port/
├─ adapter/
│  ├─ inbound/
│  │  ├─ rest/        (MVC Controller 권장: Command)
│  │  ├─ webflux/     (WebFlux 권장: Query)
│  │  └─ grpc/
│  └─ outbound/
│     ├─ jpa/         (Write)
│     ├─ r2dbc/       (Read)
│     ├─ kafka/
│     ├─ redis/
│     └─ external/
└─ config/
```

### 6.1 CQRS(Lite) 적용 방식

* **Command(Write)**: 상태 변경(Create/Update/Cancel/Confirm 등)
* **Query(Read)**: 조회 전용(상태 변경 금지)

> 초기에는 Query도 JPA로 시작할 수 있으나,
> 조회 병목이 생기면 Query만 R2DBC/캐시로 최적화한다.

---

## 7. WebFlux + MVC 하이브리드 운영 원칙

이 레포는 “둘 다 가능”하지만 **혼용 시 사고를 막기 위해 기본값을 고정**한다.

* Command(Write): **Spring MVC + JPA(Blocking)**
* Query(Read): **WebFlux + R2DBC(Non-Blocking) 또는 캐시**

금지:

* WebFlux Netty 이벤트 루프에서 JPA(Blocking) 직접 실행

---

## 8. 데이터 전략: Phase 1 → Phase 2 진화

> 상세 규칙은 `.cursor/rules/rules.mdc` 섹션 5 참조

### 8.1 Phase 1: 단일 DB + schema 분리 (배경)

물리 DB 분리는 운영 복잡도를 높인다.
초기에는 schema 분리만으로 "소유권 경계"를 강제하면서, 조인 의존을 제거해 나간다.

이렇게 하면:
- 개발 속도 유지
- 운영 단순화
- Phase 2 전환 비용 최소화

### 8.2 Phase 2: 서비스별 물리 DB 분리 (트리거)

아래 조건이 생기면 물리 분리 검토:
- 서비스별 트래픽 차이가 10배 이상
- 조직 분리로 독립 배포 필요
- 장애 격리 요구사항 발생

---

## 9. 서비스 간 데이터 결합(조인 대신)

### 9.1 기본: API Composition(권장)

정산 화면 등에서 order 정보가 필요하면 DB 조인이 아니라 API로 결합한다.

**특히 현재 요구사항: “정산 화면에 order 컬럼 10개 이내”**
→ API Composition이 가장 효율적이다.

패턴:

1. Settlement Query에서 `orderId[]` 수집
2. `POST /api/orders/summaries` 로 배치 조회
3. 서버(또는 BFF)에서 merge하여 응답

```mermaid
flowchart LR
  UI((UI)) --> GW[Gateway/BFF]
  GW --> SAPI[Settlement Query API]
  SAPI -->|orderIds[]| OAPI[Order Summary Batch API]
  SAPI --> GW --> UI
```

### 9.2 확장: Event 기반 Read Model(필요 시)

아래 조건이 생기면 Read Model 도입을 검토한다.

* 대량 목록 + 다중 조합 조회가 상시 발생
* API Composition으로 지연이 커짐
* 쿼리 최적화 비용이 증가

도입 방식:

* `shared/contracts`로 이벤트 스키마 관리
* Kafka 구독으로 조회 전용 테이블/DB 구축

---

## 10. 서비스/테이블 소유권(요약)

대표 소유권(핵심만):

* **Order Service**: `orders`, `order_dispatches`, `order_*`
* **Settlement Service**: `order_sales/purchases`, `*_bundles/*`, `charge_*`, `tax_invoices`, `invoice_issue_logs`
* **Master Service**: `companies`, `drivers`, `addresses`, `*_change_logs`
* **IAM Service**: `users`, `user_tokens`, `user_*_logs`
* **Messaging Service**: `sms_*`
* **Geo/Infra**: `distance_cache`, `kakao_api_usage`

---

## 11. 관측성/에러/보안 기본 원칙

* 모든 요청은 traceId(correlationId)를 전파한다.
* 표준 에러 응답(JSON)을 유지한다(코드/메시지/traceId/details).
* 민감정보 로그 금지(토큰/계좌/개인정보).
* 서비스 간 호출도 동일한 traceId로 연결한다.

---

## 12. 테스트 전략(최소 기준)

우선순위:

1. Domain 단위 테스트(JDK-only)
2. Application 유스케이스 테스트(Port mocking)
3. Adapter 통합 테스트(필요 범위에서)

목표:

* 도메인 규칙/상태 전이를 테스트로 고정해 “AI 생성 코드 품질”을 지킨다.

---

## 13. 개발/운영 로드맵(권장)

1. **0단계**: rules/agent/conventions로 가드레일 고정
2. **1단계**: Monorepo 뼈대 + order-service Vertical Slice 1개 완성
3. **2단계**: settlement-service + Order Summary Batch 패턴 확립
4. **3단계**: schema 분리(Phase 1) 적용 및 cross-service FK 제거/금지
5. **4단계**: 규모/조직/트래픽에 따라 물리 DB 분리(Phase 2)
6. **5단계(옵션)**: Read Model/Query Aggregator 도입

---

## 14. 신규 기능 추가 시 “DoD(완료 기준)” 체크리스트

* [ ] 대상 서비스/계층/command-query/소유 schema가 명확한가?
* [ ] Domain에 기술 의존이 없는가?
* [ ] Command/Query가 섞이지 않았는가?
* [ ] cross-service 조인/FK가 추가되지 않았는가?
* [ ] 표준 에러 응답/에러 코드 규칙을 따르는가?
* [ ] Domain 또는 Application 테스트가 최소 1개 이상 추가/수정되었는가?

---

