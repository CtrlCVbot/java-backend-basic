---
alwaysApply: true
---

# Tech Stack & Adoption Plan (Monorepo + MSA-ready)
# Domain term: "order" (cargo 금지)
# Updated: 2025-12-23

이 문서는 `java-backend-basic` 레포에서 사용하는 **기술 스택과 도입 순서(필수/권장/보류)** 를 정의한다.  
아키텍처 규칙은 `.cursor/rules/rules.mdc`가 최우선이며, 본 문서는 그 규칙을 "구현 가능한 스택"으로 구체화한다.

---

## 0. 기본 원칙(요약)

- 최종 목표: **Monorepo + MSA + Hexagonal/Clean + CQRS(Lite)**
- 초기 운영: **Phase 1(단일 Postgres + schema 분리)** 로 시작
- 진화 목표: **Phase 2(서비스별 물리 DB 분리)** 로 확장
- 웹 스택 기본값:
  - **Command(Write)**: Spring MVC + JPA (Blocking)
  - **Query(Read)**: (초기 JPA 가능) → 필요 시 WebFlux + R2DBC로 최적화
- 서비스 간 결합 기본값:
  - **API Composition(배치 요약 조회)** 우선
  - Read Model(Kafka/복제 DB)은 **필요해질 때만** 도입

---

## 1. 기술 스택(필수 / 권장 / 보류)

### 1.1 Language & Runtime
**필수**
- Java 21 (LTS)

**권장**
- Kotlin(선택): 도메인 모델/DSL 생산성 목적 (팀 합의 시)

---

### 1.2 Framework (JVM Backend)
**필수**
- Spring Boot 3.x

**권장**
- Spring Validation
- Spring Actuator (운영 메트릭/헬스체크)

**보류**
- Quarkus/GraalVM: 초고속 부팅/서버리스/Native가 “핵심 요구”가 될 때

---

### 1.3 Web Layer (MVC / WebFlux)
**필수(기본값)**
- Spring MVC (Command/Write 중심)

**권장(조건부)**
- Spring WebFlux (Query/Read, 스트리밍, 고동시성 API가 필요할 때)
  - 금지: Netty 이벤트 루프에서 JPA(Blocking) 직접 실행

---

### 1.4 Persistence (DB / ORM / Migration)
**필수**
- PostgreSQL (Supabase 포함)
- Spring Data JPA (Write 기본)
- Flyway (권장 1순위) 또는 Liquibase (둘 중 하나는 필수)
  - 목적: schema/DDL 변경을 “코드로 관리”하고 롤백/리뷰 가능하게

**권장(조건부)**
- Spring Data R2DBC (Read 전용 최적화)
- QueryDSL (복잡한 조회가 많아질 때)

**보류**
- MongoDB 등 NoSQL: 비정형 문서 요구가 명확해질 때

---

### 1.5 Cache / Session / Lock
**권장**
- Redis
  - 캐시(조회 성능)
  - 분산락(스케줄/중복 방지)
  - 세션/토큰 저장(필요 시)

**보류**
- 고급 캐시 계층(멀티레벨 캐시 등): 트래픽/비용 요구가 커질 때

---

### 1.6 Messaging & Event
**보류(기본값: 지금은 도입하지 않음)**
- Kafka / RabbitMQ / SQS-SNS

**도입 트리거(도입 조건)**
- 서비스 간 데이터 결합(API Composition)으로 지연이 커짐
- 대량 조회/집계가 상시 발생하여 Read Model이 필요
- 비동기 워크플로우(정산/세금계산서/알림 등)가 커지고 재처리/리트라이가 중요해짐

> 단, “이벤트 계약(스키마)”은 초기에 `shared/contracts`로 먼저 정의하는 것을 권장한다.

---

### 1.7 Security
**권장(실제 요구가 생기는 시점부터)**
- Spring Security
- JWT 또는 세션 기반 인증(팀 정책)

**보류**
- OAuth2, SSO, OIDC: 조직/보안 요구가 생기면 단계적으로

---

### 1.8 Observability (Metrics / Logs / Traces)
**필수(최소)**
- Spring Actuator + Micrometer (기본 메트릭)
- 구조화 로그(JSON 또는 Key-Value) + traceId(요청 상관관계)

**권장**
- OpenTelemetry (Trace)
- Prometheus + Grafana
- OpenSearch/ELK (로그 수집/검색)

**보류**
- Service Mesh(Istio/Linkerd): 운영 난이도가 높으므로 대규모에서 검토

---

### 1.9 Testing
**필수**
- JUnit 5
- Testcontainers (Postgres 최소 1개)
- Mockito(필요 시)

**권장**
- WireMock (외부 API mocking)
- REST Assured (API 테스트)
- Kafka Testcontainers (Kafka 도입 시)

---

### 1.10 DevOps / CI-CD / IaC
**권장**
- GitHub Actions (CI)
- Docker (로컬/배포)
- Terraform (IaC) / Helm (K8s)

**보류**
- ArgoCD: K8s GitOps 운영으로 갈 때
- SonarQube: 규모/품질 게이트가 필요할 때

---

## 2. “우리 레포” 기본 조합(추천 기본값)

### 2.1 MVP 기본 조합(가장 먼저)
- Java 21
- Spring Boot 3.x
- Spring MVC + JPA
- PostgreSQL (Supabase 가능)
- Flyway
- Actuator + Micrometer
- JUnit5 + Testcontainers(Postgres)

> 이 조합만으로도 “도메인/유스케이스/DB/테스트/운영 기본”이 갖춰진다.

### 2.2 확장 조합 (도입 트리거 명확화)

| 현상 | 측정 기준 | 도입 기술 |
|------|-----------|-----------|
| Query 응답 지연 | p95 > 200ms 지속 | WebFlux + R2DBC |
| 동일 조회 반복 | 캐시 히트율 예상 > 70% | Redis 캐시 |
| 서비스 간 호출 지연 | API Composition p95 > 500ms | Read Model 검토 |
| 비동기 처리 필요 | 재처리/순서보장 요구 | Kafka 도입 |
| 추적/운영 복잡도 상승 | 서비스 3개 이상, 장애 추적 어려움 | OpenTelemetry + Grafana/OpenSearch |

---

## 3. 아키텍처 운영 기본값(스택과의 연결)

### 3.1 CQRS(Lite) 운영
- Command(Write): 트랜잭션/무결성 우선 → JPA 기반
- Query(Read): 조회 유연성/속도 우선 → (초기 JPA) → 필요 시 R2DBC/캐시

### 3.2 WebFlux + MVC 하이브리드 규칙
- Command API는 MVC로 유지(기본)
- Query API는 필요 시 WebFlux로 운영
- 혼용 금지: WebFlux 핸들러에서 JPA 호출을 그대로 실행

---

## 4. 데이터 전략(Phase 1 → Phase 2)

### 4.1 Phase 1: 단일 DB + schema 분리
- 물리 DB는 하나여도 "소유권"을 schema로 강제한다.
  - `order.*`
  - `settlement.*`
  - `master.*`
  - `iam.*`
  - `messaging.*`
  - `geo.*` (infra)
- 원칙:
  - 각 서비스는 자기 schema만 접근
  - cross-service FK 신규 금지(기존은 단계적 제거)
  - 서비스 간 참조는 soft-ref(id만) 유지

#### 4.1.1 기존 cross-service FK 제거 절차

1. **현황 파악**
   - 현재 cross-service FK 목록 작성
   - 각 FK의 사용처(쿼리/애플리케이션) 파악

2. **soft-ref로 전환**
   - FK constraint 제거 (DDL)
   - 컬럼은 유지 (`order_id` 등)
   - 애플리케이션에서 참조 무결성 검증

3. **조회 로직 분리**
   - 기존 조인 쿼리 → API Composition으로 변경
   - 필요 시 캐시 추가

4. **검증 및 정리**
   - 참조 무결성 검증 로직 추가 (배치/이벤트)
   - 모니터링 후 안정화 확인

예시 마이그레이션:
```sql
-- 1. FK 제거
ALTER TABLE settlement.order_settlements
DROP CONSTRAINT fk_order_settlements_order_id;

-- 2. 인덱스 유지 (조회 성능)
CREATE INDEX idx_order_settlements_order_id
ON settlement.order_settlements(order_id);
```

### 4.2 Phase 2: 서비스별 물리 DB 분리
- Order/Settlement/Master/IAM 등으로 DB 분리
- Phase 1 규칙을 지키면 조인 의존이 없어서 분리 비용이 낮다.

---

## 5. 서비스 간 데이터 결합 표준(조인 대신)

### 5.1 기본: API Composition
- 화면에서 필요한 타 서비스 데이터가 “소량(예: 10개 컬럼 이내)”이면 기본값은 API Composition이다.

#### 표준 패턴: Order Summary Batch
- Endpoint: `POST /api/orders/summaries`
- Request:
  - `orderIds: string[]`
- Response:
  - `items: OrderSummaryResponse[]`
- 제한:
  - summary는 10개 필드 이내 유지(확장 필요 시 버전 고려)

### 5.2 확장: Event 기반 Read Model
- 대량 조회/집계가 상시 발생하고 API Composition이 병목이면 Read Model 도입
- 이벤트 스키마는 `shared/contracts`에서 버전 관리

---

## 6. 서비스별 “소유권 기준” 도입 순서(권장)

1) `order-service` (가장 먼저 Vertical Slice로 완성)
2) `settlement-service` (Order Summary Batch 결합 패턴 확립)
3) `master-service` (회사/차주/주소 원장 소유권 고정)
4) `iam-service` (인증/권한)
5) `messaging-service` (SMS/알림)

---

## 7. 도입 로드맵(실행 순서)

### 0단계: 가드레일(완료)
- `.cursor/rules/rules.mdc`
- `docs/conventions.mdc`
- `docs/agent.mdc`
- `docs/architecture.md`
- `docs/tech-stack.md` (현재 문서)

### 1단계: 레포 뼈대(모노레포 구조)
- `services/`, `shared/`, `platform/` 디렉토리 생성
- 빌드 시스템을 멀티프로젝트로 구성(Gradle 권장)
- 공통 모듈(최소):
  - `shared/errors`, `shared/contracts`, `shared/observability`

### 2단계: 개발 뼈대(서비스 생성)
- `services/order-service`에 Spring Boot 앱 생성
- MVP 스택만 적용(MVC/JPA/Flyway/Actuator/Testcontainers)

### 3단계: 패턴 확립(서비스 간 결합)
- `settlement-service` 추가
- Order Summary Batch 패턴 적용(API Composition)
- 캐시(필요 시) 도입

### 4단계: 성능/운영 확장(필요 시)
- Query 성능 문제 시 WebFlux/R2DBC 도입
- OpenTelemetry/Prometheus/OpenSearch 도입
- 이벤트/Read Model은 “명확한 트리거”가 생기면 도입

---

## 8. 체크리스트(새 기술 도입 시)

- [ ] 도입 이유가 “명확한 병목/요구사항”에 기반하는가?
- [ ] 아키텍처 규칙(.cursor/rules/rules.mdc)을 깨지 않는가?
- [ ] 서비스 간 결합을 DB 조인으로 해결하려 하지 않는가?
- [ ] 테스트/관측/롤백 전략이 있는가?
- [ ] 도입 범위를 최소화하고(한 서비스/한 유스케이스) 검증 가능한가?

---
